01


C Online Compiler

Programiz PRO ❯
main.c


Share

 Run 
    


Output
 Clear 
   25 |     printf("%d",myNumbers());


// Online C compiler to run C program online
#include <stdio.h>

int main() {

    // 잠만 vsCode, python, colab 집에 이렇게 깔려있지 ㅇㅇ
    // + java 그러면 집에 DB 깔아놔야겠네
    //mysql
    
    char mystring[] = {'a','b','\0'};
    char mystring2[] = {'a','b','\0'};
    
    printf("%d\n",mystring==mystring2);
    //찍으면 주소값 나오자너..
    //혐인터 
    
     // myAge의 주소를 표시? 저장?
    //* = 가르킨다 해서 pointer 무엇을? 주소를..
    //& = 변수의 주소
    
    char *mystring = "hello";
    char mystring2[] = "hello";
    //같은 주소값을 출력할 것..?
    //배열은 주소값을 바꿀 수 없다..
    //포인터는 주소값을 ㅕㄴ경할 수 있다.......
    
    
    
    //= a X *b = 
    
    
    
    
    
    
    return 0;
}


// 02 
7
4


1001
0111

111

2^3 	2^2 	2^1	1



1. main

a 배열 선언

*p => 배열의 초기값  - > a[0] = 10
*q => &a[3]- a3 a[3]=40 주소값인데 원래는 근데 40으로 나오더라 
왜냐하면 &a 면 주소일걸? ㅇㅇ 

change(p,q) 뭐지 값을 서로 바꾸라는거인가 

*p = 10
*q = 40

 *p = *p + *q; = 50
  *q = *p - *q;  50-40
  *p = *p - *q; 50-10

.'. *p = 40, *q =10
이때, int *q = &a[3] 
	int *p = a[0]  ~ * 는 배열의 초기값 
.'. a[0] =50,	a[3] = 10


result = 50 20 30 10 50 ....?

4. 네가 적은 부분에서의 착오

네 풀이에선 a[0] = 50이라고 결론 내렸는데,
사실 마지막 줄 *p = *p - *q; 때문에 50이 아니라 40으로 바뀌어요.

즉:

중간 단계에선 a[0] = 50이 맞음 ✅

하지만 함수 끝나면 a[0]이 다시 40으로 바뀜 → 여기서 놓친 거!  

ㅇㅇ 맞네,.. 함수가 끝났구나... 호출자가 없잖아



int num = 42;
char str[] = "Hello";
int arr[] = {1, 2, 3, 4, 5};

/* 배열과 포인터는 결국 비슷한 놈이지만,
차이점은 배열은 주소값을 변경할수 없고, 포인터는 주소값을 변경할수 있다 */
int *ptr = &num;
ptr= arr;

printf("%d\n", &num);
printf("%d\n", *ptr);
printf("%s\n", str);

// arr[0], *ptr 이거는 같다
printf("%d\n", arr[0]);
printf("%d\n", *ptr);

return 0; 

포인터가 int 같은 단일 데이터가 아닐 경우....

애초에 주소값 안물어보니까 값만 주겠구나 생각해라..
포인터로 함수만들어놓고 주면 함수값 넣고,,, 아니면 말고,,,,



포인터가 int 같은 단일 데이터가 아닐경우,
포인터나 배열이나 비슷하다
아래 코드는 포인터도 배열같이 써먹고, 배열도 포인터같이 써먹을수 있다는 예제이다

// 같은 값이 나오는 서로 다른 표현 방법.
char str[] = "Hello";
char *ptr_a = str;
char **ptr_b = &ptr_a; // 이중 포인터
printf("%c\n", str[1]); // e
printf("%c\n", *(ptr_a + 1)); // e
printf("%c\n", ptr_a[1]); // e
printf("%c\n", *(*ptr_b + 1)); // e
printf("%c\n", (*ptr_b)[1]); // e
char str2[] = "World";
*ptr_b = str2;
printf("%c\n", ptr_a[1]); // o

평범한 struct 변수는 . 

struct , pointer 는 화살표로 ...
포인터로 가르킨 값은 가르킨 값 밖에 못뽑는다.


틈틈이 등장하는 malloc은 -> Memony ALLOCation의 줄임말.
무조건 int =n , 또는 int *arr = (int *) malloc(5 * sizeof(int)); 이런식으로 줄 건데
그냥 arr[n] 과 같다고 보면 된다.

